#### 오늘의 급등주 찾기

---

1. 급등하기 이전의 데이터를 모아온다
2. 라벨을 붙인다. 급등인지 아닌지
3. 모델을 장착해서 학습시킨다.
4. test 데이터를 주어 예측해본다. 
5. 정확도를 산출해본다.



#### 적용 지표

___

> * MA60
> * 급등 이전 차트



#### 논리화

---

* 정해진 기간내에 상승폭이 가장 큰 구간을 찾은 후 기간의 시작점을 찾아 그 전 데이터를 TRAINX로 지정한다.

* _X -> _Y 를 내가 만들어주면 된다. (dataX.append(X) & dataY.append(Y))

* 다음 10 개의 상승폭이 최대가 되는 점을 기준으로 이전 데이터를 취한다.

  > 상승폭을 계산할 수 있는 지표는?
  >
  > MAX CLOSE & CLOSE GAP

* 공통된 패턴으로 예상할 수 있기 때문에 거래 종목에 무관하게 데이터를 취할 수 있다.

* 새로운 TARGETY = 지점으로 부터 다음 10개 데이터의 상승폭

* TARGETY의 값이 지정값 이상인 경우 거래를 진행하면 되지 않을까

  > 많은 데이터를 보유한 상황이 아니기 때문에, 종합적으로 사용할 수 있는 TRAINX 형식을 사용한다.
  >
  > ~~(불연속적인 데이터 추출로 다양한 종목에서 긁어올 수 있다.)~~ 
  >
  > (연속적으로 긁어도 데이터 전처리에서 일정 상승폭을  기준으로 Y 값을 이진화시키면 다양한 종목에서 데이터를 추출할 수 있다고 예상)
  >
  > `>>`  CNN 사용가능

* 이진화로 전처리한 다음은 ? Regression 이 아니라 Classifier 로 분류한다.

  `>>` 어떤 모델을 사용할건지

  > 이건 나중에 생각해도 되고, 일단은 TRAINX, TRAINY 를 산출해보도록 한다.



#### 정확도 올리는 방법

---

> 1. increase the **dataset**
> 3.  apply other **preprocessing **steps like data augmentation
> 4.  increase the number of **epochs**... more training more better
> 5. change the architecture (better to try builtin models)
> 6. update the model with optimum settings.. e.g. change the optimizer, learning rate, loss function



#### ACC_Params

---

* row & col
* y_pred : np.argmax >> percentage
* ohlcv.shape  일치시키기
* Augmentation
* layers



## Result : val_loss / val_acc & Y_pred / Y_test

* 24 : 0.31104 / 0.8899 Y_pred / Y_test : 0.9543913713405239
* 54 : 0.29058 / 0.9129 Y_pred / Y_test : 0.9617286914765907
* 96 : 0.24431 / 0.9445 Y_pred / Y_test : 0.9638247098383773
* 150 : 0.23040 / 0.9420 Y_pred / Y_test : 0.9571859554528532
* 216 : 0.19574 / 0.9574 Y_pred / Y_test : 0.9382318271119843
* 294 : 0.16398 / 0.9638 Y_pred / Y_test : 0.9436450839328537

## Result2 : Variable Params

 0.21552



## 백테스트

1. predict ohlcv 를 만든다.
2. 돌린다.



# 코드 구현

#### 1. 매수 시점 = 급등 예상시

* 이전 종가를 n 개 긁어서 급등 여부를 확인하고, 급등확인시 진입. 
* 얼마 동안 매수 대기할건지 = 10분
* 이전 종가를 다양한 코인에 모두 적용하면, 크롤링 제한당할 텐데 이거는 방법이 없을까?
  * IP 우회해야하나..



#### 1-1. 매수가 = 저점 피크



-----



#### 2. 매도 시점 = 매수 직후, 지정 매도가 체결될 때까지



#### 2-1. 매도가 = 고점 피크

* 사용지표로 MA3 CLOSE 사용할 수 있다.



#### 3. 이탈에 대한 보정 작업 - IN DETAIL

* 오지게 떨어지는 경우가 존재하는데 어느정도 회복하려면 저점찍고 올라왔을때 팔아버리면 ?

* 애초에 스케일러가 MinMax 0, 1 로 지정해서 급상승해도 상승폭이 작은 경우를 걸러준다. 

  > 수수료 값만 나온다.

* 시간으로 보정하는 건 말이 안되는 것 같다.



#### + 패턴

> * MA 기울기가 음수인 경우
>   * 양수로 변할때까지 대기
>   * 자글거리는 꾸불거림은 무시할 수 있어야 한다. >> **이걸 위해서 MA 를 사용한건데, 다른 대안책이 존재하면 후행 지표인 MA 를 사용하지 않아도 된다 !**
> * MA 기울기가 양수인 경우
>   * 주가가 MA 위에 있는지 아래 있는지를 고려
>     * MA 위에 있으면 상승 확률이 높다.
> * 저점과 고점 이미지 데이터를 모아서 CLASSIFIER 로 분류해주기, 해서 다시 한번 예측 ?



# GPU 사용



## 필요한 것

* 매수점 (저점) >> 저점 패턴

* 정상 매도점 (이익을 최대치할 수 있는) >> 피크 패턴

* 이탈 보정

* 인지 과정 : 자글자글한 변동을 MA 로 무시할 수 있다. (경향성을 누적시킨다)

  > MA ? 을 사용할 수 있나
  >
  > 1. 신호점 부터 저점까지 이미지 데이터
  > 2. 매수점 부터 고점까지 이미지 데이터
  >
  > CMO == 선행지표 : 사용 가능할 거 같은데
  >
  > * 저점과 고점을 인식하는 머신을 만들 수 있을 거 같은데

  > * 저점 찍고  오를 기미가 보인다 >> 진입한다.
  > * 매수세가 거세다.
  >   * 지정 매도가를 넘었다 >> 
  >   * 넘지 못했다 >> 
  > * 저점이 안생기고 계속 하락한다 >> 일정시간 동안 저점을 잡는다.