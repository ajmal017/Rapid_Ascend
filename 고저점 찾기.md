#### 정확도 올리는 방법

---

> 1. 데이터 양 늘리기
> 3.  데이터 전처리
> 4.  데이터 epoch 수 늘리기
> 5. 모델 변경
> 6. optimizer, activation func 변경



#### ACC_Params

* **데이터 전처리가 제일 중요하다**
  
  * 들어가는 열 수 (low, high >> cmo)
  
  * ohlcv.shape  일치시키기
  
  * 이전 이후 데이터 보다 작은 피크만 찾는다.
  
  * > 잡음을 일으키는 데이터를 제거해주는 것이 중요
* 데이터 편향, 가중치 적용
* Augmentation
* layers
* 데이터 후처리
  
  * y_pred : np.argmax >> percentage
  * slice_ohlcv 의 길이가 input_data_length 보다 작은 경우 출력 결과값의 오차가 커진다.



## Result : Variable Params

* 0.20972
  * layer 크게에서 작게 256 128 64
* 0.2054
  *  layer 층을 확 줄임

* 0.2007 
  *  layer 노드 수 유지 128

* 0.19808
  *   pool 2,2, 마지막 kernel size = 3

* 0.19346 
  *  kenel=1,  augumentation 증가, train, test, valid 비율 변경

* 0.19244
  * dense relu 추가, kernel size = 3, batch 가 다름 (64, 128)
* 0.19064
  * augumentation 증가, batch 128=128
  * 60 angles, 0.6 shift, 128 nodes



| Best Model : softmax / categorical_crossentropy / batch_size=128 / rotation=60 / h_flip=True / width_shift=0.6 / height_shift=0.6 / fill_mode='nearest / filter_amt=100 |                                        |
| ------------------------------------------------------------ | -------------------------------------- |
| Low                                                          | High                                   |
| 0.02767  LSTM, SIGMOID                                       | 0.02877     기존에 사용하던 BEST MODEL |
| 0.02725   Best Model / 2 layer                               |                                        |
| 0.02715   filter_amt=100, 2 layers                           | 0.02792   Same with Low versions       |
| 0.02633  input_data_length=40                                | 0.02715                                |

check_span 을 줄여보기 / data 의 양을 늘려보기 >> 정확도가 좋다고 수익률이 무조건적으로 좋은건 아니다.

data_weight 에 따른 np.sum(Y_pred) 의 값 비교

vertical_flip=True 해보기

opt 변경해보기

epoch 올려서 비교해보기

batch size 조절해보기

모델 이어서 학습하기

RNN 으로 해보기

LSTM 적용해보기 : https://www.kaggle.com/ist597/simple-keras-lstm-classifier-98-74

https://www.kaggle.com/afajohn/cnn-lstm-for-signal-classification-lb-0-513/notebook



# 코드 구현

#### 1. 매수 시점 = 저가

#### 2. 매수가 = 오픈가

* 실제 코드 = 오픈가

#### 3. 매도 시점 =고가

#### 4. 매도가 = 오픈가 ?

* high 의 80 % 로 매도했다고 가정 
* 실제 코드 = ex. 오픈가 찍고 얼마안돼서 시장가 매도

#### 5. 이탈에 대한 보정 작업

* 매수 신호만 있고 매도 신호가 없는 경우는 ..?

  > 항목을 나열해주고 총 갯수 산출



### GPU 사용



## Modi.

* 고점에 팔아야 가장 큰 이익을 가져올텐데 고점이 형성되지 않는 경우에 대해서 생각해보기
  
  * figure_data 에서는 잡는데, figure_fluc 에서는 잡지 못하는 점 >> ACC 를 올린다.
  
    > ### high 가 중요함 (매도 시점을 정확하게 파악해야한다)
  
* 해당 코인이 아직 남아있는 경우
